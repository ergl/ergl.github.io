tags: pvc_client_coordinator imdea
title: Constant Partition Access
type: text/vnd.tiddlywiki

We're going to calculate the partition of a key multiple times, in multiple parts of the code. It is important that this operation is fast enough.

By default, the Ring representation from riak core is `{Size :: non_neg_integer(), List :: list({partition_id(), node()})`. To get the key index node, we do `N = Hash(Key) mod Size` and then `lists:nth(N, List)`. `lists:nth` is a linear search iteration through `List` since it is implemented as a linked list.

Since this structure is not going to change through the lifetime of the code (we don't contemplate vnode rebalancing right now), we can convert this ring representation to a constant-access one. Erlang offers tuples as a primitive data type, offering index-based access with no overhead. However, writes will make a copy of the entire tuple. This is not a problem for us, since we're never updating this code. (see http://erlang.org/doc/efficiency_guide/commoncaveats.html#setelement-3)

To convert it, we do

```
{ok, Ring} = riak_core_ring_manager:get_my_ring(),
%% Chash is {
%% NumPartitions :: non_neg_integer(),
%% Partitions :: [{partition_id(), node()}]
%% }
{Num, Layout} = CHash = riak_core_ring:chash(Ring),

%% erlang:make_tuple/3 requires
%% 1. Size of the final tuple (we have Num)
%% 2. A default value for the tuple (we can ignore this)
%% 3. A proplist of {Position, Element}, to denote the contents
%% We don't have (3), but we can construct it like so
Contents = lists:zip(lists:seq(1, Num), Nodes),
%% To avoid creating a list, we could use recursion too

Output = erlang:make_tuple(Num, ignore, Contents).
```