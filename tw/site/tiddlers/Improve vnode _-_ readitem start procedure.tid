tags: task
task-readitem_improv-step: 2
title: Improve vnode <-> readitem start procedure
type: text/vnd.tiddlywiki

clocksi_vnode on `start_read_servers` does `loop_until_started`, which (in theory), should start all read servers, doing:

```
loop_until_started(_Partition, 0) ->
    0;
loop_until_started(Partition, Num) ->
    Ret = clocksi_readitem_server:start_read_servers(Partition, Num),
    loop_until_started(Partition, Ret).
```

So here, `clocksi_readitem_server:start_read_servers` //will// return the next server to start (wtf?)

In turn, `clocksi_readitem_server` will:

```
start_read_servers(Partition, Count) ->
    Addr = node(),
    start_read_servers_internal(Addr, Partition, Count).

start_read_servers_internal(_Node, _Partition, 0) ->
    0;
start_read_servers_internal(Node, Partition, Num) ->
    case clocksi_readitem_sup:start_fsm(Partition, Num) of
        {ok, _Id} ->
            start_read_servers_internal(Node, Partition, Num-1);
        {error, {already_started, _}} ->
            start_read_servers_internal(Node, Partition, Num-1);
        Err ->
            lager:debug("Unable to start clocksi read server for ~w, will retry", [Err]),
            try
                gen_server:call({global, generate_server_name(Node, Partition, Num)}, {go_down})
            catch
                _:_Reason->
                    ok
            end,
            start_read_servers_internal(Node, Partition, Num)
    end.
```

This means, if the server (noted by `Num`), is spawned correctly, or already up, spawn the next one `Num - 1`

```
case clocksi_readitem_sup:start_fsm(Partition, Num) of
    {ok, _Id} ->
        start_read_servers_internal(Node, Partition, Num-1);
    {error, {already_started, _}} ->
        start_read_servers_internal(Node, Partition, Num-1);
```

If something goes badly, tell the server to go down, and restart.

```
Err ->
    lager:debug("Unable to start clocksi read server for ~w, will retry", [Err]),
    try
        gen_server:call({global, generate_server_name(Node, Partition, Num)}, {go_down})
    catch
        _:_Reason->
            ok
    end,
    start_read_servers_internal(Node, Partition, Num)
```

When the recursive call stops, it will return `0` ...

```
start_read_servers_internal(_Node, _Partition, 0) ->
    0;
...
```

... which `clocksi_vnode` will interpret as

```
loop_until_started(_Partition, 0) ->
    0;
```

thereby skipping the rest of servers.

So:

* clocksi_vnode will enter a loop, on the first iteration ask clocksi_readitem_server to start //one// server, and expecting to get the next server to start afterwards.
* clocksi_readitem_server will ignore this, and start //all// the servers at this node, and return `0`, to skip the rest of calls
* clocksi_vnode sees this, skips the rest of calls, and returns

---